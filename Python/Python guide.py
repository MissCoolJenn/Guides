# ************************************************************************************************************************************************************************************
# // - деление
print(20 // 6)# = 3 (деление без остатка)
# % - остаток после деления
print(20 % 6)# = 2 (деление с остатком как результат)

print(format(3.3248935, ".1f")) # format - граничивает количество символов в float после запятой 

a = "f"
print(a.isupper()) # буква в нижнем регистре, так что вывод будет - False


# ************************************************************************************************************************************************************************************
# ПРОВЕРИТЬ ТИП ОБЪЕКТА
q = 1
print(type(q))
# <class 'int'>


# ************************************************************************************************************************************************************************************
# СКОЛЬКО РАЗ ЧИСЛО ВСТРЕЧАЕТСЯ С СПИСКЕ
l1 = [1, 2, 3, 2, 4, 2, 5]
print(l1.count(2))  # получится 3 (так как 2 встречается с списке 3 раза)


# ************************************************************************************************************************************************************************************
# КАК СДЕЛАТЬ ПЕРВУЮ БУКВУ В СТРОКЕ БОЛЬШОЙ
s = 'hello world'
s = s.capitalize()
print(s) # выведет "Hello world" 


# ************************************************************************************************************************************************************************************
# ЗАПЯТАЯ В print
q1 = 'ballsd'
q2 = 'asdo'
print(f'{q1}, {q2}') # получится 'ballsd, asdo'

#ограничение количества символов после запятой
print(round(3/2, 2))
#                ^ значение символов после запятой


# ************************************************************************************************************************************************************************************
# STR TO INT
q = '21323'
s = int(q)


# ************************************************************************************************************************************************************************************
# DATETIME
from datetime import datetime
datetime.today().strftime('%d/%m/%Y') # выводит сегоднешнюю дату ввиде: (день/месяц/год)

# больше там
# https://pythonworld.ru/moduli/modul-datetime.html

# сторока даты в формат datetime
from datetime import datetime
dateString = "31.12.2022"
print(datetime.strptime(dateString, "%d.%m.%Y")  ) # получится 2022-12-31 00:00:00
#                                                     ^ если добавить .strftime('%d/%m/%Y') - получится 31/12/2022

#узнать разницу дат
from datetime import datetime, timedelta
date_input = '06.01.2023'
date = datetime.strptime(date_input, "%d.%m.%Y") # перевод из str в формат datetime в виде: 2022-01-06 00:00:00
print(date - timedelta(days=7)) # получится дата из date_input, но на 7 дней раньше: 2021-12-30 00:00:00
#                       ^   ^ сколько дней нужно отнять от date1
#                       | можно указать seconds, years, days и т.д.

# временная метка в datetime
from time import time
timestamp = time()
print(timestamp)  # получится 1579596626.421213 (временная метка в секундах наверное с начала эры кодинга)

# преобразование временной метки в нормальный формат ГГГГ-ММ-ДД ЧЧ-ММ-СС.МС
date_time = datetime.fromtimestamp(timestamp)
print(date_time)


# ************************************************************************************************************************************************************************************
# ПЕРЕМЕННАЯ ВНУТРИ СТРОКИ
q = 123
print(f'какой то текст, число: {q}, и опять текст') # получится: какой то текст, число: 123, и опять текст


# ************************************************************************************************************************************************************************************
# ОТСУТСВИЕ ЗНАЧЕНИЯ
q = None


# ************************************************************************************************************************************************************************************
# ОШИБКИ (исключения)
try:
    print(7 / 0)
    print("наебал мир")
except :# ZeroDivisionError - деление на 0
        # ValueError - правильный тип данных, но значение не подходит
        # TypeError - неправильный тип данных
        # KeyError - попытка сослаться на ключ которого нет в словаре
        # MemoryError - попытка создать слишком большой список (списковое включение)
        # AttributeError - попытка вызова атрибута которого нет в классе
    print("оу, не получилось наебать мир?")
finally:
    print("i shitted my chair") # выполнится в любом случае


# ************************************************************************************************************************************************************************************
# ФАЙЛЫ
file = open("file_name.txt", "r") # "r" - чтение фала
                                  # "w" - запись в файл, если файла нет - будет создан новый (предыдущее содержимое будет удалено)

file = open("file_name.txt", "r") # открыть файл "название_файла.txt"
q = file.read() # прочитать файл и присвоить переменной "q" его содержимое
#            ^(можно указать число - сколько будет прочитано символов)
print(q) # ну тут понятно
file.close() # закрыть файл

file = open("file_name.txt", "r") 
for line in file: # перебрать в цикле и напечатать отдельно каждую линию в файле
    print(line)
file.close()

print(len(open("file_name.txt").readlines())) # будет напечатано цифра сколько строк в файле

file = open("file_name.txt", "w") 
file.write("какой то текст для новой строки") # написать в файле строку 
file.close()

file = open("file_name.txt", "w")
q = "какой то текст"
w = file.write(q) # если получится записать в файл переменную "q", то "w" станет равной len(q)
if (w == len(q)): # это будет работать
    print("прикольная фича") 

# лучше всего использовать такую конструкцию:
try: # если в этой части кода будет ошибка...
    f = file.open("file_name.txt")
    print(f)
finally: # ...то здесь файл в любом случае будет закрыт
    file.close()

# открыть файл через with:
with open('file.txt', 'a') as q:
    print(q)
    q.write('asdlkgs') # дописать в файл новый текст


# ************************************************************************************************************************************************************************************
# СПИСОК
qqqq = ["q", "w", "r", "r"] # список от 0 до len(qqqq) - можно что то добавить и можно что то удалить
print(qqqq[0]) # получится q

a = [1, 4, 7, 8] # разворот списка
print(list(reversed(a))) # получится [8, 7, 4, 1]

qqqq.append('ss')  # добавить 'ss' в список
qqqq.remove('q')   # удалить 'q' из списка  (удаление по значению)
del qqqq[2]        # удалить 'r' из списка  (удаление по индексу)

qqqq.sort()      # получится ['q', 'r', 'r', 'w']


# ************************************************************************************************************************************************************************************
# СПИСОК В СПИСКЕ или МАТРИЦА
q = [[0, 1, 3], ['sq', 'lsd', 'dragon dildo']]
print(q)       # получится [[0, 1, 3], ['sq', 'lsd', 'dragon dildo']]
print(q[0])    # получится [0, 1, 3]
print(q[0][2]) # полутся 3


# ************************************************************************************************************************************************************************************
#  СПИСКОВОЕ ВКЛЮЧЕНИЕ
qwe = [i*2 for i in range(q) if i ** 2 % 2 == 0]
#                            ^ условие добавление в список 
#                              (к примеру если число i во 2й спепени не оставит остатся косле деления на 2)
#       ^ генератор чисел от i*2, повторять range(q) раз



# ************************************************************************************************************************************************************************************
# МНОЖЕСТВА - неупорядоченый список уникальных значений (они не могут там повторяться) (работает быстрее чем просто список - т.к. является хэш приколом)
nums = {1, 2, 3, 4, 5, 6} #значения не могут повторятся
nums = set()   # создание пустого множества
nums.add(7)    # добавить значение
nums.remove(1) # удалить значение

cocl = {45, 2, 7, 34, 64}
print(nums & cocl) # общие значения
print(nums | cocl) # объединяет два множества в одно
print(nums - cocl) # возвращяет значение только первого множества и только те которых нет во втором множестве
print(nums ^ cocl) # не общие значения 

# ************************************************************************************************************************************************************************************
# КОРТЕЖ
eeee = ("q", "w", "e") # список который нельзя редактировать
print()

# РАСПАКОВКА КОРТЕЖЕЙ
numbers = (1, 2, 4)
q, w, e = numbers
print(q, e) # получится 1, 4

numbers = (1, 2, 5, 8, 9, 3, 7, 5)
q, w, *e, t = numbers # *переменная - забирает себе все остальные значение которые остались после других переменных
print(q, "\\", w, "\\", e, "\\", t) # получится 1 \\ 2 \\ [5, 8, 9, 3, 7] \\ 5


# ************************************************************************************************************************************************************************************
# СРЕЗ из списка или кортежа 
qqqq = ["q", "w", "r", "r", "y", "u"]
print(qqqq[2:4]) # вывести часть списка "qqqq", получится ["r", "r"]
#           ^ от какого символа : до какого - 1 (то есть не включительно!)
print(qqqq[2:-1]) # если использовать отрицательное чисто - отсчет будет идти с  противоположного конца списка
#           ^ получится ['r', 'r', 'y']
print(qqqq[:4]) # если не указать первый или последний параметр - срез будет от 0го значения или до последнего
#           ^ получится ["q", "w", "r", "r"]
print(qqqq[0:4:q]) # 3й парамент отвечает за шаг (будет показан у указаном диапазоне каждый q елемент)
#              ^ если q = 2 - получится ["q", "r"]


# ************************************************************************************************************************************************************************************
# функции MAP и FILTER
nums = [1, 2, 4, 6, 8, 9] 
res = list(map(lambda x: x+5, nums)) 
#           ^ map - к каждому значению в списке применяет первое выражение в скобках(к примеру lambda = x + 5)
#      ^ list - (для того, что бы результат вывелся как список)
print(res) # получится [6, 7, 9, 11, 13, 14] 

nums = [1, 2, 4, 6, 8, 9] 
res = list(filter(lambda x: x % 2 == 0, nums))
#            ^ filter - фильтрует значения из списка если первое выражение в скобках == True 
#                                         к примеру (если число не имеет остатка после деления на 2 == True)
#      ^ list - (для того, что бы результат вывелся как список)
print(res) #


# ************************************************************************************************************************************************************************************
# СЛОВАРЬ он же ХЭШ
wwww = {"q": 1, "w": [1, 2, 3], "e": [3, "fuck мой мозг"]} # словарь (ключ где "q"= 1 и т.д.)

wwww["r"] = "новый ключ" # так можно добавлять ключи в словарь
print(wwww["w"]) # получится 1, 2, 3

nuts = {"q": 1, "q2": 4, "q3": 6,}
print(q in nuts) # получится True
print(qq in nuts) # получится False
print(qeweq not in nuts) #получится True

wwww = {"q": 1, "w": [1, 2, 3], "e": [3, "fuck мой мозг"]}
print(wwww.get(q)) # получится "1"
print(wwww.get(123)) # получится "None"
print(wwww.get(12365, "не найдено")) # получится "не найдено"

my_dict = {'01:24': 46, '02:15': 78, '03:30': 90}
last_key, last_value = my_dict.popitem()   # .popitem() - отдает послдние ключ/значение из словаря после чего из словаря они удаляються
print(last_key, last_value)  # получится: '03:30', 90
print(my_dict)   # получится: {'01:24': 46, '02:15': 78}

sss = '{"q": 1, "w": [1, 2, 3], "e": [3, "fuck мой мозг"]}'
www = eval(sss)  # преобразует строку в словарь 

www.clear()     # удаляет все элементы словаря, но не удаляет сам словарь

q_list = [1, 2, 3]
www.fromkeys(q_list)  # преобразует список в словарь
# получится: {1: None, 2: None, 3: None}

my_dict = {'01:24': 46, '02:15': 78, '03:30': 90}  # создает список со всеми значениями из словаря
value_list = list(my_dict.values())  # получится ['46', '78', '90']

import json
q = json.dumps(www)  # преобразует словарь в строку
file.write(q)


# ************************************************************************************************************************************************************************************
# ГРАФ (он же набор словарей)
graph = {} 
graph['electric'] = ['samokat', 'car', 'bike']  # первый уровень графа 'electric' - он осотоит из спика ['samokat', 'car', 'bike']
graph['samokat'] = ['xiaomi', 'bolt']           # второй уровень графа 'electric' относящийся к графу 'samokat' в котором: ['xiaomi', 'bolt']
graph['car'] = ['tesla', 'bmw', 'porshe']       # второй уровень графа 'electric' и т.д.
graph['bike'] = ['gravel', 'mtb']               # и т.д.
 
 
# ************************************************************************************************************************************************************************************
# ФОРМАТИРОВАНИЕ СТРОК
name = input() # к примеру если "name" = deb
age = int(input()) # к примеру если "age" = 666
w = "{q} is a very old hui, his age - {w}".format(q=name, w=age)
#(можно не использовать как раньше кучу занаков + между переменными и текстом
print(w) # получится "deb is a very old hui, his age - 666"


# ************************************************************************************************************************************************************************************
# ФУНКЦИИ ОБРАБОТКИ СТРОК
print(", ".join(['spam', 'eggs', 'balls'])) #   получится "spam, eggs, balls"
#   первые "" буду использованы как промежуток между всем что в внутри списка .join([])

print("love niggers".replace("love", "i hate")) # получится "i hate niggers"
#   .replace("то что будет заменено", "на что будет заменено")

print('aso qasoif aoep'.startswith("aso")) # == True
#      ^ если в начале текста есть ^ - получится "True"
print('aso qasoif aoep'.endswith('aoep')) # == True
#      ^ если в конце текста есть ^ - получится "True"

print("giganiga".upper()) # получится GIGANIGA   - увеличение всего текста до больших букв
print("GIGANIGA".lower()) # получится giganiga   - уменьшение всех текста до маленьких букв

print("asw, waopij, aeifgh, af".split(", ")) # получится ["asw", "waopij", "aeifgh", "af"]
#     ^ разделить текст на список если ^ есть разделитель в тексте


# ************************************************************************************************************************************************************************************
# ЧИСЛОВЫЕ ФУНКЦИИ
x = [1, 2, -3, 4, 3, -5, 4]
print(min(x))   # минимальное число в списке "х"
print(max(x))   # максимальное число в списке "х"
print(abs(-99)) # убирает в числе знак "-" - получится 99
print(abs(26))  # получится 26
print(sum(x))   # сумма всех чисел в списке "х"


# ************************************************************************************************************************************************************************************
# ЛЯМБДА
func_name = lambda x, y: x + y # я бы сказал что это def в одну строку
#                  ^  ^ аргументы которые принимает лямбда, и потом расчитывает, в конце делает return значения
print(func_name(3, 4)) 


# ************************************************************************************************************************************************************************************
# РЕКУРСИЯ 
def fib(x):
    if (x == 0 or x == 1):
        return 1
    else:
        return fib(x - 1) + fib(x + 2)
print(fib(4)) # получится 5, потому что схема такая:
#                         fib(4)
#               I-----------^-----------I
#             fib(3)        +         fib(2)
#          I----^----I             I----^----I
#       fib(2)  +  fib(1)       fib(1)  +  fib(0)
#    I----^----I
# fib(1)  +  fib(0) 


# ************************************************************************************************************************************************************************************
# БЕСКОНЕЧНОЕ КОЛИЧЕСТВО АРГУМЕНТОВ
def yeh(x, *args):
    print(x + sum(args))
yeh(1, 2, 4, 5, 7, 8)


# ************************************************************************************************************************************************************************************
# ГЕНЕРАТОР

# пример генератора который при вызове отдает по букве из заданной строки:
def gen(x):
    for i in x:
        yield i  # yield - вернуть данные, и временно остановить работу на этом месте
g = gen('peperoni')

# пример того, что получится :
print(next(g))   # p
print(2+3)       # 5
print(next(g))   # e
print("sdjdjg")  # sdjdjg
print(next(g))   # p
print(next(g))   # e
print("22")      # 22

# next(g) - продолжить работу функции или с начала или с предыдущего yield до следующего yield


# ************************************************************************************************************************************************************************************
# КЛАССЫ
class Name: # класс
    def __init__(self, length, weather): # self и потом атрибуты
        self.length = length   # определение атрибутов
        self.weather = weather # определение атрибутов
    
    def secondDef(self):
        print("im second def)")

pipi = Name(14, "rain") # присваивание переменной pipi класса Name и передача ему 2х аргументов
pipi.weather = "sunny"
print(pipi.weather, pipi.length) # получится "rain 14" / вызов аргументов из класса
print(pipi.secondDef()) # получится im second def)     / вызов второй функции из класса 


# ************************************************************************************************************************************************************************************
# НАСЛЕДОВАНИЕ КЛАССОВ
class Animal: # класс у которого есть подкласс - становится суперклассом 
    def __init__(self, name, color):
        self.name = name
        self.color = color
    def test(self):
        print("yeah, its for test")

class Cat(Animal): # класс становится подклассом Animal
    def __init__(self, name, color, height):
        super().__init__(name, color) # "name" и "color" передаются родительскому классу
        self.height = height                # "height" объявляется только в дочернем      
    def meow(self):
        print("meow")
        super().test() # super() - функция для поиска указаного метода в суперклассе 

ggg = Cat("not gay", "green") # передача атрибутов сначала подклассу Cat а потом это передастся суперклассу Animal
print(ggg.color, ggg.meow) # получится green meow


# ************************************************************************************************************************************************************************************
# МАГИЧЕССКИЕ МЕТОДЫ 
class Q: 
    def __init__(self, x, y): 
        self.x = x
        self.y = y
    
    def __add__(self, other): # как я понял - при добавлении маг. метода - его функия сама вызывается и обрабатывает данные
        #__init__     - метод для суперкласса по умолчанию
        # __str__     - (яндекс практикум) (я так и не пон зачем он надо)
        #__add__      - +
        #__sub__      - -
        #__mul__      - *
        #__truediv__  - /
        #__floordiv__ - //
        #__mod__      - %
        #__pow__      - **
        #__and__      - &
        #__xor__      - ^
        #__or__       - |

            #__len__      - для len()
            #__getitem__  - для индексации
            #__setitem__  - для присваивания значение индексированому элементу
            #__delitem__  - для удаление индексированых елементов
            #__iter__     - для перебора елеменов (например в циклах while или for)
            #__contains__ - для in

                # del "имя переменной" - для удаления переменной из памяти
                #__del__               - магичесский вариант обычного del
        return Q(self.x + other.x, self.y + other.y) # 

firstQ = Q(3, 7)
secondQ = Q(6, 5)
result = firstQ + secondQ
print(result.x) # получится 9
print(result.y) # получистя 12 


# ************************************************************************************************************************************************************************************
# МЕТОДЫ КЛАССА  
class pipa(): # класс
    min_cords = 1 # атрибуты класса
    max_cords = 100

    @classmethod # метод который - сслылается на сам класс и...
                    # может взаимодействовать с атрибутами и staticmethods внутри своего класса
    def validate(cls, arg): # 
        return cls.min_cords <= arg <= cls.max_cords

    def __init__(self, x, y): # метода который - ссылается на экземпляр класса и... 
                                    # может взаемодействовать с экземпляром, с атибутами и матодами
        self.x = self.y = 0
        if self.validate(x) and self.validate(y):
            self.x = x
            self.y = y
    
    def coord(self):
        return self.x, self.y

    @staticmethod # метод который - не может ни с чем взаимодействовать, кроме своих атрибутов (x, y)
    def norm2(x, y):
        return x*x + y*y

v = pipa(1, 1021) # экземпляр класса
print(pipa.norm2(4, 6)) # получится 52 


# ************************************************************************************************************************************************************************************
# ПУБЛИЧНЫЕ, ПРИВАТНЫЕ, ЗАЩИЩЕННЫЕ АТРИБУТЫ 
class what():
    def __init__(self, name, hui_sm, bank_balance):
        self.name = name
        self._hui_sm = hui_sm
        self.__bank_balance = bank_balance

    def give(self):
        print(self.name, self._hui_sm, self.__bank_balance)

dude1 = what("joe mama", 11, 66621836)
print(dude1.name)         # атрибут публичный и можно к нему обратится из любой части кода
print(dude1._hui_sm)      # атрибут приватный, обратится можно, но помечается "_" если обращатся вне метода не рекомендуется 
print(dude1__bank_balance) # атрибут защищенный, обратиться к нему вне класса не получится - будет вывод "NameError: name 'dude1__bank_balance' is not defined"


# ************************************************************************************************************************************************************************************
# свойства PROPERTY
class what():
    def __init__(self, name, hui_sm):
        self.__name = name
        self.__hui_sm = hui_sm

    @property # по умолчанию здесь будет getter
    def pisya(self):
        return self.__hui_sm

    @pisya.setter # setter - декаратор для записи нового значения
        #  getter  - декоратор для получения имеющегося значения
        #  deleter - декоратор для удаления имеющегося значения
    def pisya(self, hui_sm):
        self.__hui_sm = hui_sm

dude1 = what("joe mama", 11) # создание профиля
print(dude1.pisya) # если просто вызвать метод с декоратором property - вызовется getter
dude1.pisya = 14 # если вызвать метод с декоратором property и написать "= (значение)" - вызовется setter
print(dude1.pisya) # (получить новое, измененное setter'om значение)


# ************************************************************************************************************************************************************************************
# РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ (работа со строками)
import re
old = "what is 44 hours in week?" # строка с текстом 
pattern = "what"                  # строка которая будет заменена

pattern = re.compile(r"/d+kg")     # - компилирует условие r"" что бы его можно было использовать с методами match. ...
text = 'i have 100kg fried ^_^'
match = pattern.search(text)        # - например выделить место которое подходит по паттерну 
mass = match.group()                # - преобразовать в строку метку типа <re.Match object; span=(7, 12), match='100kg'>
print('my frind weight is:', mass)  # - вставить в другой текст

# pattern.finditer()                # - возвращает совпадения ввиде регулярных выражений, тип - <_sre.SRE_Match object; span =(34, 37), match ="hui">

match = re.search(pattern, old)     # - ищет по всему тексту совпадения (работает до первого совпадения)
match = re.findall(pattern, old)    # - ищет все совпадения в тексте, результат ввиде кортежа, тип - ("hui", "eblan", "pisya")
q = match.group()                   # - возвращает все совпадения ввиде либо строки либо кортежа
q = match.start()                   # - возвращает начальный символ на котором начинается совпадение
q = match.end()                     # - возвращает последний символ на котором заканчивается совпадение
q = match.span()                    # - начальный и последний символ первого совпадения ввиде кортежа
new = re.sub(pattern, "666", old)   # re.sub - заменяет указаный текст в строке на новый 

# МЕТАСИМВОЛЫ
import re
word = "grey"
pattern = r"^gr.y$" # r - для определения сырой строки 
                    # ^ - начало строки
                    # . - любой символ
                    # $ - конец строки 
                    # n{q} - искать n подряд q раз
                    # n{q, w} - искать n подряд от q до w раз
                    # к"gr(a|e)y" - метасимвол или gr(или a или e)y
                    # "[...]*" - ноль или более упоминаний символов поиска в скобках
                    # "[...]+" - одно или более упоминаний символов поиска в скобках
                    # "...(.)?..." - ноль или одно упоминаний символов поиска в скобках
                    # "..{0,1}$" - для поиска упоминаний мужду двумя числами (по умолчанию первое число 0, второе бесконечность)
if re.match(pattern, word):
    print(word) # получится word

# СПЕЦИАЛЬНЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ
# \d - любая цифра
# \D - всё что угодно, кроме цифр
# \s - пробелы
# \S - всё что угодно, кроме пробелов
# \w - буква
# \W - всё что угодно, кроме букв
# \b - последний символ слова
# \B - не последний символ слова
# \a - начало строки
# \A - не начало строки
# \z - конец строки
# \Z - не конец строки
import re
pattern = r"(\D+\d)"
if re.match(pattern, "as893 3V"):
    print("1") # получистя 
elif re.match(pattern, "234 6546"):
    print("2") # не получится 
elif re.match(pattern, "#@8 30 3"):
    print("3") # не получится 

import re
word = "asflkjlg"
pattern = r"[asfhjf]" # набор символов
#         r"[a-s]" - набор символов от "a" до "s"
#         r"[^a-d]" - набор символов всё, кроме от a до d
if re.match(pattern, word): # True если в стороке будет хотя бы один символ из набора символов
    print("yes")


# ************************************************************************************************************************************************************************************
# ГРУППЫ
import re
pattern = r"saf(asko)*"
if (pattern, "askokdsfdgf"):
    print("yep")        # не получится 
elif (pattern, "safdsogfh"):
    print("second yep") # получится

match = re.match(pattern, "safgfok")
print(match.group(0)) # получить группу 0
print(match.group())  # получить все группы начиная с первой
# (?:....) - незахватывающия группа, к ней нельзя обратится по номеру группы, не имеет номера, не нарушает нумерацию групп


# ************************************************************************************************************************************************************************************
# АСИНХРОННОСТЬ - ASYNC AWAIT (pip install isynchio)
import time
import asyncio

# печать начала времени выполнения кода
print ('begin:', time.strftime('%X'))  # "begin: 14:32:51"

async def first():  # запускается первой
    print('first sleep 3s')
    await asyncio.sleep(3)  # делает паузу выполнения текущей задачи при этом не останавлия остальной код других задач
    print (2+2)
    print ('first:', time.strftime('%X'))

async def second():  # запускается второй паралельно первой, не дожидаясь пока завершится first()
    print('second sleep 3s')
    await asyncio.sleep(3)
    print (3-6)
    print ('second:', time.strftime('%X'))

async def main():  # функция работает как список асинхронных задач 
    task1 = asyncio.create_task(first())   # создание асинхронной задачи 1
    task2 = asyncio.create_task(second())  # создание асинхронной задачи 2

    await task1  # |
    await task2  # | паралельный запуск двух задач

asyncio.run(main())  # запуск списка асинхронных задач

# async - обозначение функции которая будет запускаться в асинхронном режиме
# await - обозначение запуска задачи при котором текущая задача работает паралельно с другим кодом/задачами из функции списка задач